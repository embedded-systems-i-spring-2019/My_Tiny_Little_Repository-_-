library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity fancy_counter is
  Port (clk, clk_en, dir, en, ld, rst, updn: in std_logic;  --These are all the 1 bit inputs of the multiplexer
        val: in std_logic_vector(3 downto 0);               --This is the special input of the multiplexer that has a 4-bit input
        cnt: out std_logic_vector(3 downto 0));             --This is the special out of the multiplexer that has a 4-bit out
end fancy_counter;

architecture Behavioral of fancy_counter is
--intermediate signals

--need a 4 bit counter
signal counter: std_logic_vector(3 downto 0) := (others => '0');    --This is the interchangeable value of the counter
signal value: std_logic_vector(3 downto 0) := (others => '0');      --
signal direction : std_logic := '0';

begin
--begin process
    process(clk, clk_en)                  --Notice here that we have two clocks
        begin
        
        --unless en = '1' do nothing
        if(en = '1') then
        
        --on the clock rising (while clock_en is "0" ) edge and rst is asserted once there is a rising edge, and counter resets aswell
            if(rising_edge(clk)) then
                if (rst = '1') then              --This just resets the system which will make the output give a "0"
                counter <= (others => '0');     --This resets the counter, which will automatically output a "0" in 4-bit form
                --this sets output to 0
                cnt <= counter;      -this just assigns the actual "0" value of the counter to the output
                
                --beside rst, (while clock_en is "1") clk_en and "en" have to be '1' for a change in anything to happen.
                elsif (clk_en = '1') then
                --if ld is 1
                --the value at "val" will be LOADED in to value register
                    if(ld = '1') then
                    value <= val;
                    end if;
                    
                    --Second case: if clk_en = '1' and updn = '1'
                    --change counting direction depending on dir value
                    if(updn = '1') then         --this activates change of count
                    direction <= dir;           --this changes counting direction
                    end if;
                    
                    --COUNT UP depending on the value of "direction register". In this case it is counts up to number stored in value
                    --this case happens as long as updn is "1"
                        if(direction = '1') then
                           if(unsigned(counter) < unsigned(value)) then
                               counter <= std_logic_vector(unsigned(counter) + 1);
                               --once reached reset back to 0000
                               --set output to value in counter
                                cnt <= counter;
                           else
                               counter <= (others => '0');        --This just resets counter
                               --set output to value in counter
                               cnt <= counter;
                           end if;
                           
                        
                        else          --if direction is '0'(as long as updn is "1")
                        --COUNT DOWN from current value in counter
                            if(unsigned(counter) > "0000") then
                                counter <= std_logic_vector(unsigned(counter) - 1);   --This is where the counter starts counting in reverse
                                --puts the value of the counter on the output
                                cnt <= counter;  
                         --(if it doesn't meet the condition above) if it reaches 0000 set to val    
                            else
                            counter <= value;
                            cnt <= counter;      --puts the value of the counter on the output
                            end if;              --Remember the loop goes back at every clock edge (count)
                        end if;
                 end if;
            end if;
      end if;
                 
   end process;

end Behavioral;
