library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;a

entity fancy_counter is
  Port (clk, clk_en, dir, en, ld, rst, updn: in std_logic;  --These are all the 1 bit inputs of the multiplexer
        val: in std_logic_vector(3 downto 0);               --This is the special input of the multiplexer that has a 4-bit input
        cnt: out std_logic_vector(3 downto 0));             --This is the special out of the multiplexer that has a 4-bit out
end fancy_counter;

architecture Behavioral of fancy_counter is
--intermediate signals

--need a 4 bit counter
signal counter: std_logic_vector(3 downto 0) := (others => '0');    --This is the interchangeable value of the counter
signal value: std_logic_vector(3 downto 0) := (others => '0');      --interchangeable  "value"
signal direction : std_logic := '0';                                --interchangeable  "direction"

begin
--begin process
    process(clk, clk_en)                  --Notice here that we have two clocks
        begin
        
        --unless en = '1' do nothing
        if(en = '1') then
        
        --(clock_en is "0" ) if rst is asserted while on rising edge, the counter resets and the output "cnt" becomes a 4-bit "0"
        --Remember the value of the counter and the out are the same and are also both 4-bits
            if(rising_edge(clk)) then
                if (rst = '1') then              --This just resets the system which will make the output give a "0"
                counter <= (others => '0');     --This resets the counter, which will automatically make its 4-bit value be "0000"
                cnt <= counter;                 --This puts the 4-bit temporary "counter" onto entitiy port "cnt"
                
                --(while  clock_en is "1") clk_en and "en" have to be '1' for a change in anything to happen.
                elsif (clk_en = '1') then

                    if(ld = '1')   then      --if ld is 1  the value at "val" will be LOADED in to value register
                    value <= val;       --Here we actually put the entity port "val" into the temporary 4-bit "value" so that we can move "val" later
                    end if;

                        --Second case: if en=1, clk_en = '1', ld=1, and updn = '1' change counting direction depending of dir value
                        if(updn = '1') then         --this JUST activates change in count direction
                        direction <= dir;           --this puts entitiy port "dir" (which can be 0 or 1)into the temporary 4-bit "direction", so that we can move "dir" later
                        end if;
                    
                                if(direction = '1') then         --In this case it  "dir" decides whether to count up or down       
                                       if(unsigned(counter) < unsigned(value)) then    --Check if "counter" is less than "value" 
                                           counter <= std_logic_vector(unsigned(counter) + 1);    --adds 1 to the counter than saves it in the temporary "counter"
                                            cnt <= counter;               --puts the temporary "counter" into the entity port "cnt". So that it can be printed out
                                            
                                       else                               --This is the case that the temporary "counter" is is more than the temporary "value" applied to the multiplexer 
                                           counter <= (others => '0');    --This is will reset the temporary "counter" giving it a value of "0000"
                                           cnt <= counter;                --puts the temporary "counter" into the entity port "cnt". So that it can be printed out
                                       end if;
                           
                        
                                else          --if direction is '0'(as long as updn is "1"). COUNT DOWN from current value in counter
                                       if(unsigned(counter) > "0000") then
                                          counter <= std_logic_vector(unsigned(counter) - 1);   --This is where the counter starts counting in reverse
                                          cnt <= counter;    --puts the value of the counter on the output
                         
                                       else  --If the "counter" is actually 0000 , "val" is sent to "counter"   
                                            counter <= value;
                                            cnt <= counter;   --The temporary "counter" is put on the entity port "cnt", so it can be printed out   
                            end if;              --Remember the loop goes back at every clock edge (count)
                        end if;
                 end if;
            end if;
      end if;
                 
   end process;

end Behavioral;
